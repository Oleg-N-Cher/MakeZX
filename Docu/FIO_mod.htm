<!--
This file was generated by Web C Plus Plus software v0.7.9
Webcpp Copyright (C)2001, (C)2002 Jeffrey Bakker under the GNU GPL
Get webcpp at http://webcpp.sf.net
-->

<html>
<head>
<title>FIO.mod</title>
<style type="text/css">

/** Webcpp v0.7.0+ compatible StyleSheet http://webcpp.sf.net **/
/** Theme: typical **/

body
{
background-color: #ffffff
}

a:link    {color:#ff0000}
a:visited {color:#666666}
a:active  {color:#0000ff}
a:hover   {color:#00b800}

pre
{
color: #000000
}

font
{
font-size:100%
}

font.preproc
{
color: #00b800
}

font.numbers
{
color: #a900a9
}

font.strings
{
color: #ff0000
}

font.keyword
{
color: #0000ff;
font-weight: bold
}

font.comment
{
color: #666666;
font-style: italic
}

</style>
</head>
<body>
<pre>

<font CLASS=keyword>IMPLEMENTATION</font> <font CLASS=keyword>MODULE</font> FIO ;

<font CLASS=comment>(*
    Title      : FIO
    Author     : Gaius Mulley
    System     : UNIX (gm2)
    Date       : Thu Sep  2 22:07:21 1999
    Last edit  : Thu Sep  2 22:07:21 1999
    Description: a complete reimplememtation of FIO.mod
                 provides a simple buffered file input/output library.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>FROM</font> SYSTEM <font CLASS=keyword>IMPORT</font> ADR, TSIZE, SIZE, WORD ;
<font CLASS=keyword>FROM</font> ASCII <font CLASS=keyword>IMPORT</font> nl, nul, tab ;
<font CLASS=keyword>FROM</font> Math <font CLASS=keyword>IMPORT</font> ABS ;
<font CLASS=keyword>FROM</font> StrLib <font CLASS=keyword>IMPORT</font> StrLen, StrConCat, StrCopy ;
<font CLASS=keyword>FROM</font> StrIO <font CLASS=keyword>IMPORT</font> WriteLn;
<font CLASS=keyword>FROM</font> MemUtils <font CLASS=keyword>IMPORT</font> MemCopy ;
<font CLASS=keyword>FROM</font> Storage <font CLASS=keyword>IMPORT</font> ALLOCATE, DEALLOCATE ;
<font CLASS=keyword>FROM</font> NumberIO <font CLASS=keyword>IMPORT</font> CardToStr ;
<font CLASS=keyword>FROM</font> libc <font CLASS=keyword>IMPORT</font> exit, open, creat, read, write, close, lseek ;

<font CLASS=keyword>CONST</font>
   SEEK_SET            =       <font CLASS=numbers>0</font> ;   <font CLASS=comment>(* relative from beginning of the file *)</font>
   UNIXREADONLY        =       <font CLASS=numbers>0</font> ;
   CreatePermissions   =     <font CLASS=numbers>666</font>B;
   MaxNoOfFiles        =     <font CLASS=numbers>100</font> ;
   MaxBufferLength     = <font CLASS=numbers>1024</font>*<font CLASS=numbers>16</font> ;
   MaxErrorString      = <font CLASS=numbers>1024</font>* <font CLASS=numbers>8</font> ;

<font CLASS=keyword>TYPE</font>
   FileUsage         = (unused, openedforread, openedforwrite, openedforrandom) ;
   FileStatus        = (successful, outofmemory, toomanyfilesopen, failed, connectionfailure) ;

   NameInfo          = <font CLASS=keyword>RECORD</font>
                          address: ADDRESS ;
                          size   : <font CLASS=keyword>CARDINAL</font> ;
                       <font CLASS=keyword>END</font> ;

   Buffer            = <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> buf ;
   buf               =            <font CLASS=keyword>RECORD</font>
                                     position: <font CLASS=keyword>CARDINAL</font> ;  <font CLASS=comment>(* where are we through this buffer *)</font>
                                     address : ADDRESS ;   <font CLASS=comment>(* dynamic buffer address           *)</font>
                                     filled  : <font CLASS=keyword>CARDINAL</font> ;  <font CLASS=comment>(* length of the buffer filled      *)</font>
                                     size    : <font CLASS=keyword>CARDINAL</font> ;  <font CLASS=comment>(* maximum space in this buffer     *)</font>
                                     left    : <font CLASS=keyword>CARDINAL</font> ;  <font CLASS=comment>(* number of bytes left to read     *)</font>
                                     contents: <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> <font CLASS=keyword>ARRAY</font> [<font CLASS=numbers>0</font>..MaxBufferLength] <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font> ;
                                  <font CLASS=keyword>END</font> ;

   FileDescriptors   = <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> fds ;
   fds               =            <font CLASS=keyword>RECORD</font>
                                     unixfd: <font CLASS=keyword>INTEGER</font> ;
                                     name  : NameInfo ;
                                     state : FileStatus ;
                                     usage : FileUsage ;
                                     output: <font CLASS=keyword>BOOLEAN</font> ;     <font CLASS=comment>(* is this file going to write data *)</font>
                                     buffer: Buffer ;
                                     abspos: <font CLASS=keyword>CARDINAL</font> ;    <font CLASS=comment>(* absolute position into file.     *)</font>
                                  <font CLASS=keyword>END</font> ;

<font CLASS=comment>(* we only need forward directives for the p2c bootstrapping tool *)</font>

<font CLASS=comment>(* %%%FORWARD%%%
PROCEDURE FormatError (a: ARRAY OF CHAR) ; FORWARD ;
PROCEDURE FormatError1 (a: ARRAY OF CHAR; w: WORD) ; FORWARD ;
PROCEDURE FlushBuffer (f: File) ; FORWARD ;
PROCEDURE CheckAccess (f: File; use: FileUsage; towrite: BOOLEAN) ; FORWARD ;
PROCEDURE WriteString (f: File; a: ARRAY OF CHAR) ; EXTERN ;
PROCEDURE ReadString (f: File; VAR a: ARRAY OF CHAR) ; EXTERN ;
   %%%FORWARD%%% *)</font>

<font CLASS=keyword>VAR</font>
   FileInfo: <font CLASS=keyword>ARRAY</font> [<font CLASS=numbers>0</font>..MaxNoOfFiles] <font CLASS=keyword>OF</font> FileDescriptors ;


<font CLASS=comment>(*
   GetUnixFileDescriptor - returns the UNIX file descriptor of a file.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> GetUnixFileDescriptor (f: File) : <font CLASS=keyword>INTEGER</font> ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL)
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>RETURN</font>( FileInfo[f]^.unixfd )
   <font CLASS=keyword>ELSE</font>
      FormatError1(<font CLASS=strings>'file %d has not been opened or is out of range\n'</font>, f)
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> GetUnixFileDescriptor ;


<font CLASS=comment>(*
   Max - returns the maximum of two values.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> Max (a, b: <font CLASS=keyword>CARDINAL</font>) : <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> a&gt;b
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>RETURN</font>( a )
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( b )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> Max ;


<font CLASS=comment>(*
   Min - returns the minimum of two values.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> Min (a, b: <font CLASS=keyword>CARDINAL</font>) : <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> a&lt;b
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>RETURN</font>( a )
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( b )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> Min ;


<font CLASS=comment>(*
   GetNextFreeDescriptor - returns the index to the FileInfo array indicating
                           the next free slot. If we run out of slots then we
                           return MaxNoOfFiles.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> GetNextFreeDescriptor () : File ;
<font CLASS=keyword>VAR</font>
   f: File ;
<font CLASS=keyword>BEGIN</font>
   f := <font CLASS=numbers>0</font> ;
   <font CLASS=keyword>WHILE</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL) <font CLASS=keyword>DO</font>
      f := f+File(<font CLASS=numbers>1</font>)   <font CLASS=comment>(* --fixme-- compiler should allow INC(f) *)</font>
   <font CLASS=keyword>END</font> ;
   <font CLASS=keyword>RETURN</font>( f )
<font CLASS=keyword>END</font> GetNextFreeDescriptor ;


<font CLASS=comment>(*
   IsNoError - returns a TRUE if no error has occured on file, f.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> IsNoError (f: File) : <font CLASS=keyword>BOOLEAN</font> ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>RETURN</font>(
          (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL) <font CLASS=keyword>AND</font> (FileInfo[f]^.state=successful)
         )
<font CLASS=comment>(* was for p2c 
   IF (f&lt;MaxNoOfFiles) AND (FileInfo[f]#NIL)
   THEN
      RETURN( (FileInfo[f]^.state=successful) )
   ELSE
      RETURN( FALSE )
   END
<font CLASS=comment>*)</font></font>
<font CLASS=keyword>END</font> IsNoError ;


<font CLASS=comment>(*
   Exists - returns TRUE if a file named, fname exists for reading.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> Exists (fname: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>) : <font CLASS=keyword>BOOLEAN</font> ;
<font CLASS=keyword>VAR</font>
   f: File ;
<font CLASS=keyword>BEGIN</font>
   f := OpenToRead(fname) ;
   <font CLASS=keyword>IF</font> IsNoError(f)
   <font CLASS=keyword>THEN</font>
      Close(f) ;
      <font CLASS=keyword>RETURN</font>( <font CLASS=keyword>TRUE</font> )
   <font CLASS=keyword>ELSE</font>
      Close(f) ;
      <font CLASS=keyword>RETURN</font>( <font CLASS=keyword>FALSE</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> Exists ;


<font CLASS=comment>(*
   StrCopyM2C - copy a modula-2 string into a C style string.
                Given an address, a, and string, b.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> StrCopyM2C (a: ADDRESS; b: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>) ;
<font CLASS=keyword>VAR</font>
   p      : <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> <font CLASS=keyword>CHAR</font> ;
   i, high: <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>BEGIN</font>
   p := a ;
   i := <font CLASS=numbers>0</font> ;
   high := StrLen(b) ;
   <font CLASS=keyword>WHILE</font> i&lt;high <font CLASS=keyword>DO</font>
      p^ := b[i] ;
      INC(p) ;
      INC(i)
   <font CLASS=keyword>END</font> ;
   <font CLASS=comment>(* add the nul *)</font>
   p^ := nul
<font CLASS=keyword>END</font> StrCopyM2C ;


<font CLASS=comment>(*
   InitializeFile - initialize a file descriptor
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> InitializeFile (f: File; fname: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>;
                          fstate: FileStatus; use: FileUsage; towrite: <font CLASS=keyword>BOOLEAN</font>; buflength: <font CLASS=keyword>CARDINAL</font>) : File ;
<font CLASS=keyword>BEGIN</font>
   NEW(FileInfo[f]) ;
   <font CLASS=keyword>IF</font> FileInfo[f]=NIL
   <font CLASS=keyword>THEN</font>
      FileInfo[MaxNoOfFiles]^.state := outofmemory ;
      <font CLASS=keyword>RETURN</font>( MaxNoOfFiles )
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         name.size := StrLen(fname)+<font CLASS=numbers>1</font> ;  <font CLASS=comment>(* need to guarentee the nul for C *)</font>
         usage     := use ;
         output    := towrite ;
         ALLOCATE(name.address, name.size) ;
         <font CLASS=keyword>IF</font> name.address=NIL
         <font CLASS=keyword>THEN</font>
            state := outofmemory ;
            <font CLASS=keyword>RETURN</font>( f )
         <font CLASS=keyword>END</font> ;
         StrCopyM2C(name.address, fname) ;
         abspos := <font CLASS=numbers>0</font> ;
         <font CLASS=comment>(* now for the buffer *)</font>
         NEW(buffer) ;
         <font CLASS=keyword>IF</font> buffer=NIL
         <font CLASS=keyword>THEN</font>
            FileInfo[MaxNoOfFiles]^.state := outofmemory ;
            <font CLASS=keyword>RETURN</font>( MaxNoOfFiles )
         <font CLASS=keyword>ELSE</font>
            <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
               size     := buflength ;
               position := <font CLASS=numbers>0</font> ;
               filled   := <font CLASS=numbers>0</font> ;
               <font CLASS=keyword>IF</font> size=<font CLASS=numbers>0</font>
               <font CLASS=keyword>THEN</font>
                  address := NIL
               <font CLASS=keyword>ELSE</font>
                  ALLOCATE(address, size) ;
                  <font CLASS=keyword>IF</font> address=NIL
                  <font CLASS=keyword>THEN</font>
                     state := outofmemory ;
                     <font CLASS=keyword>RETURN</font>( f )
                  <font CLASS=keyword>END</font>
               <font CLASS=keyword>END</font> ;
               <font CLASS=keyword>IF</font> towrite
               <font CLASS=keyword>THEN</font>
                  left := size
               <font CLASS=keyword>ELSE</font>
                  left := <font CLASS=numbers>0</font>
               <font CLASS=keyword>END</font> ;
               contents := address ;  <font CLASS=comment>(* provides easy access for reading characters *)</font>
            <font CLASS=keyword>END</font> ;
            state := fstate
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font> ;
   <font CLASS=keyword>RETURN</font>( f )
<font CLASS=keyword>END</font> InitializeFile ;


<font CLASS=comment>(*
   ConnectToUnix - connects a FIO file to a UNIX file descriptor.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> ConnectToUnix (f: File; towrite: <font CLASS=keyword>BOOLEAN</font>) ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL)
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=keyword>IF</font> towrite
         <font CLASS=keyword>THEN</font>
            unixfd := creat(name.address, CreatePermissions)
         <font CLASS=keyword>ELSE</font>
            unixfd := open(name.address, UNIXREADONLY, <font CLASS=numbers>0</font>)
         <font CLASS=keyword>END</font> ;
         <font CLASS=keyword>IF</font> unixfd&lt;<font CLASS=numbers>0</font>
         <font CLASS=keyword>THEN</font>
            state  := connectionfailure
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> ConnectToUnix ;


<font CLASS=comment>(*
   OpenToRead - attempts to open a file, fname, for reading and
                it returns this file.
                The success of this operation can be checked by
                calling IsNoError.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> OpenToRead (fname: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>) : File ;
<font CLASS=keyword>VAR</font>
   f: File ;
<font CLASS=keyword>BEGIN</font>
   f := GetNextFreeDescriptor() ;
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      f := InitializeFile(f, fname, successful, openedforread, <font CLASS=keyword>FALSE</font>, MaxBufferLength) ;
      ConnectToUnix(f, <font CLASS=keyword>FALSE</font>)
   <font CLASS=keyword>ELSE</font>
      FileInfo[f]^.state := toomanyfilesopen
   <font CLASS=keyword>END</font> ;
   <font CLASS=keyword>RETURN</font>( f )
<font CLASS=keyword>END</font> OpenToRead ;


<font CLASS=comment>(*
   OpenToWrite - attempts to open a file, fname, for write and
                 it returns this file.
                 The success of this operation can be checked by
                 calling IsNoError.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> OpenToWrite (fname: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>) : File ;
<font CLASS=keyword>VAR</font>
   f: File ;
<font CLASS=keyword>BEGIN</font>
   f := GetNextFreeDescriptor() ;
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      f := InitializeFile(f, fname, successful, openedforwrite, <font CLASS=keyword>TRUE</font>, MaxBufferLength) ;
      ConnectToUnix(f, <font CLASS=keyword>TRUE</font>)
   <font CLASS=keyword>ELSE</font>
      FileInfo[f]^.state := toomanyfilesopen
   <font CLASS=keyword>END</font> ;
   <font CLASS=keyword>RETURN</font>( f )
<font CLASS=keyword>END</font> OpenToWrite ;


<font CLASS=comment>(*
   OpenForRandom - attempts to open a file, fname, for random access
                   read or write and it returns this file.
                   The success of this operation can be checked by
                   calling IsNoError.
                   towrite, determines whether the file should be
                   opened for writing or reading.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> OpenForRandom (fname: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>; towrite: <font CLASS=keyword>BOOLEAN</font>) : File ;
<font CLASS=keyword>VAR</font>
   f: File ;
<font CLASS=keyword>BEGIN</font>
   f := GetNextFreeDescriptor() ;
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      f := InitializeFile(f, fname, successful, openedforrandom, towrite, MaxBufferLength) ;
      ConnectToUnix(f, towrite)
   <font CLASS=keyword>ELSE</font>
      FileInfo[f]^.state := toomanyfilesopen
   <font CLASS=keyword>END</font> ;
   <font CLASS=keyword>RETURN</font>( f )
<font CLASS=keyword>END</font> OpenForRandom ;


<font CLASS=comment>(*
   Close - close a file which has been previously opened using:
           OpenToRead, OpenToWrite, OpenForRandom.
           It is correct to close a file which has an error status.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> Close (f: File) ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      <font CLASS=comment>(*
         although we allow users to close files which have an error status
         it is sensible to leave the MaxNoOfFiles file descriptor alone.
      *)</font>
      <font CLASS=keyword>IF</font> FileInfo[f]#NIL
      <font CLASS=keyword>THEN</font>
         FlushBuffer(f) ;
         <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
            <font CLASS=keyword>IF</font> unixfd&gt;=<font CLASS=numbers>0</font>
            <font CLASS=keyword>THEN</font>
               <font CLASS=keyword>IF</font> close(unixfd)#0
               <font CLASS=keyword>THEN</font>
                  FormatError1(<font CLASS=strings>'failed to close file (%s)\n'</font>, WORD(name.address)) ;   <font CLASS=comment>(* cast only necessary for p2c *)</font>
                  state := failed   <font CLASS=comment>(* --fixme-- too late to notify user (unless we return a BOOLEAN) *)</font>
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font> ;
            <font CLASS=keyword>IF</font> name.address#NIL
            <font CLASS=keyword>THEN</font>
               DEALLOCATE(name.address, name.size)
            <font CLASS=keyword>END</font> ;
            <font CLASS=keyword>IF</font> buffer#NIL
            <font CLASS=keyword>THEN</font>
               <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
                  <font CLASS=keyword>IF</font> address#NIL
                  <font CLASS=keyword>THEN</font>
                     DEALLOCATE(address, size)
                  <font CLASS=keyword>END</font>
               <font CLASS=keyword>END</font> ;
               DISPOSE(buffer)
            <font CLASS=keyword>END</font>
         <font CLASS=keyword>END</font> ;
         DISPOSE(FileInfo[f]) ;
         FileInfo[f] := NIL
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> Close ;


<font CLASS=comment>(*
   WriteString - writes a string to file, f.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> WriteString (f: File; a: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>) ;
<font CLASS=keyword>VAR</font>
   l: <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>BEGIN</font>
   l := StrLen(a) ;
   <font CLASS=keyword>IF</font> WriteNBytes(f, l, ADR(a))#l
   <font CLASS=keyword>THEN</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> WriteString ;


<font CLASS=comment>(*
   ReadFromBuffer - attempts to read, nBytes, from file, f.
                    It firstly consumes the buffer and then performs
                    direct unbuffered reads. This should only be used
                    when wishing to read large files.

                    The actual number of bytes read is returned.
                    -1 is returned if EOF is reached.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> ReadFromBuffer (f: File; a: ADDRESS; nBytes: <font CLASS=keyword>CARDINAL</font>) : <font CLASS=keyword>INTEGER</font> ;
<font CLASS=keyword>VAR</font> 
   result: <font CLASS=keyword>INTEGER</font> ;
   total,
   n     : <font CLASS=keyword>CARDINAL</font> ;
   p     : <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> BYTE ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      total := <font CLASS=numbers>0</font> ;   <font CLASS=comment>(* how many bytes have we read *)</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=comment>(* extract from the buffer first *)</font>
         <font CLASS=keyword>IF</font> buffer#NIL
         <font CLASS=keyword>THEN</font>
            <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
               <font CLASS=keyword>IF</font> left&gt;<font CLASS=numbers>0</font>
               <font CLASS=keyword>THEN</font>
                  <font CLASS=keyword>IF</font> nBytes=<font CLASS=numbers>1</font>
                  <font CLASS=keyword>THEN</font>
                     <font CLASS=comment>(* too expensive to call MemCopy for 1 character *)</font>
                     p := a ;
                     p^ := contents^[position] ;
                     DEC(left) ;         <font CLASS=comment>(* remove consumed bytes               *)</font>
                     INC(position) ;     <font CLASS=comment>(* move onwards n bytes                *)</font>
                     nBytes := <font CLASS=numbers>0</font> ;       <font CLASS=comment>(* reduce the amount for future direct *)</font>
                                         <font CLASS=comment>(* read                                *)</font>
                     INC(abspos) ;
                     <font CLASS=keyword>RETURN</font>( <font CLASS=numbers>1</font> )
                  <font CLASS=keyword>ELSE</font>
                     n := Min(left, nBytes) ;
                     MemCopy(ADDRESS(<font CLASS=keyword>CARDINAL</font>(address)+position), n, a) ;
                     DEC(left, n) ;      <font CLASS=comment>(* remove consumed bytes               *)</font>
                     INC(position, n) ;  <font CLASS=comment>(* move onwards n bytes                *)</font>
                                         <font CLASS=comment>(* move onwards ready for direct reads *)</font>
                     a := ADDRESS(<font CLASS=keyword>CARDINAL</font>(a)+n) ;
                     DEC(nBytes, n) ;    <font CLASS=comment>(* reduce the amount for future direct *)</font>
                                         <font CLASS=comment>(* read                                *)</font>
                     INC(total, n) ;
                     INC(abspos, n)
                  <font CLASS=keyword>END</font>
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font>
         <font CLASS=keyword>END</font> ;
         <font CLASS=keyword>IF</font> nBytes&gt;<font CLASS=numbers>0</font>
         <font CLASS=keyword>THEN</font>
            <font CLASS=comment>(* still more to read *)</font>
            result := read(unixfd, a, <font CLASS=keyword>INTEGER</font>(nBytes)) ;
            <font CLASS=keyword>IF</font> result&gt;<font CLASS=numbers>0</font>
            <font CLASS=keyword>THEN</font>
               INC(total, result) ;
               INC(abspos, result)
            <font CLASS=keyword>ELSE</font>
               <font CLASS=comment>(* eof reached, set the buffer accordingly *)</font>
               state := failed ;
               <font CLASS=keyword>IF</font> buffer#NIL
               <font CLASS=keyword>THEN</font>
                  <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
                     left     := <font CLASS=numbers>0</font> ;
                     position := <font CLASS=numbers>0</font> ;
                     <font CLASS=keyword>IF</font> address#NIL
                     <font CLASS=keyword>THEN</font>
                        contents^[position] := nul
                     <font CLASS=keyword>END</font>
                  <font CLASS=keyword>END</font>
               <font CLASS=keyword>END</font> ;
               <font CLASS=keyword>RETURN</font>( -<font CLASS=numbers>1</font> )
            <font CLASS=keyword>END</font>
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font> ;
      <font CLASS=keyword>RETURN</font>( total )
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( -<font CLASS=numbers>1</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> ReadFromBuffer ;


<font CLASS=comment>(*
   ReadNBytes - reads nBytes of a file into memory area, a, returning
                the number of bytes actually read.
                This function will consume from the buffer and then
                perform direct libc reads. It is ideal for large reads.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> ReadNBytes (f: File; nBytes: <font CLASS=keyword>CARDINAL</font>; a: ADDRESS) : <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>VAR</font>
   n: <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      CheckAccess(f, openedforread, <font CLASS=keyword>FALSE</font>) ;
      n := ReadFromBuffer(f, a, nBytes) ;
      <font CLASS=keyword>IF</font> n&lt;<font CLASS=numbers>0</font>
      <font CLASS=keyword>THEN</font>
         <font CLASS=keyword>RETURN</font>( <font CLASS=numbers>0</font> )
      <font CLASS=keyword>ELSE</font>
         <font CLASS=keyword>RETURN</font>( n )
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( <font CLASS=numbers>0</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> ReadNBytes ;


<font CLASS=comment>(*
   BufferedRead - will read, nBytes, through the buffer.
                  Similar to ReadFromBuffer, but this function will always
                  read into the buffer before copying into memory.

                  Useful when performing small reads.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> BufferedRead (f: File; nBytes: <font CLASS=keyword>CARDINAL</font>; a: ADDRESS) : <font CLASS=keyword>INTEGER</font> ;
<font CLASS=keyword>VAR</font> 
   result: <font CLASS=keyword>INTEGER</font> ;
   total,
   n     : <font CLASS=keyword>INTEGER</font> ;
   p     : <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> BYTE ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      total := <font CLASS=numbers>0</font> ;   <font CLASS=comment>(* how many bytes have we read *)</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=comment>(* extract from the buffer first *)</font>
         <font CLASS=keyword>IF</font> buffer#NIL
         <font CLASS=keyword>THEN</font>
            <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
               <font CLASS=keyword>WHILE</font> nBytes&gt;<font CLASS=numbers>0</font> <font CLASS=keyword>DO</font>
                  <font CLASS=keyword>IF</font> left&gt;<font CLASS=numbers>0</font>
                  <font CLASS=keyword>THEN</font>
                     <font CLASS=keyword>IF</font> nBytes=<font CLASS=numbers>1</font>
                     <font CLASS=keyword>THEN</font>
                        <font CLASS=comment>(* too expensive to call MemCopy for 1 character *)</font>
                        p := a ;
                        p^ := contents^[position] ;
                        DEC(left) ;         <font CLASS=comment>(* remove consumed byte                *)</font>
                        INC(position) ;     <font CLASS=comment>(* move onwards n byte                 *)</font>
                        INC(total) ;
                        INC(abspos) ;
                        <font CLASS=keyword>RETURN</font>( total )
                     <font CLASS=keyword>ELSE</font>
                        n := Min(left, nBytes) ;
                        MemCopy(ADDRESS(<font CLASS=keyword>CARDINAL</font>(address)+position), <font CLASS=keyword>CARDINAL</font>(n), a) ;
                        DEC(left, n) ;      <font CLASS=comment>(* remove consumed bytes               *)</font>
                        INC(position, n) ;  <font CLASS=comment>(* move onwards n bytes                *)</font>
                                            <font CLASS=comment>(* move onwards ready for direct reads *)</font>
                        a := ADDRESS(<font CLASS=keyword>CARDINAL</font>(a)+n) ;
                        DEC(nBytes, n) ;    <font CLASS=comment>(* reduce the amount for future direct *)</font>
                                            <font CLASS=comment>(* read                                *)</font>
                        INC(total, n) ;
                        INC(abspos, n)
                     <font CLASS=keyword>END</font>
                  <font CLASS=keyword>ELSE</font>
                     <font CLASS=comment>(* refill buffer *)</font>
                     n := read(unixfd, address, size) ;
                     <font CLASS=keyword>IF</font> n&gt;=<font CLASS=numbers>0</font>
                     <font CLASS=keyword>THEN</font>
                        position := <font CLASS=numbers>0</font> ;
                        left     := n ;
                        filled   := n ;
                        INC(abspos, n) ;
                        <font CLASS=keyword>IF</font> n=<font CLASS=numbers>0</font>
                        <font CLASS=keyword>THEN</font>
                           <font CLASS=comment>(* eof reached *)</font>
                           state := failed ;
                           <font CLASS=keyword>RETURN</font>( -<font CLASS=numbers>1</font> )
                        <font CLASS=keyword>END</font>
                     <font CLASS=keyword>ELSE</font>
                        position := <font CLASS=numbers>0</font> ;
                        left     := <font CLASS=numbers>0</font> ;
                        filled   := <font CLASS=numbers>0</font> ;
                        abspos   := <font CLASS=numbers>0</font> ;
                        state    := failed ;
                        <font CLASS=keyword>RETURN</font>( total )
                     <font CLASS=keyword>END</font>
                  <font CLASS=keyword>END</font>
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font> ;
            <font CLASS=keyword>RETURN</font>( total )
         <font CLASS=keyword>ELSE</font>
            <font CLASS=keyword>RETURN</font>( -<font CLASS=numbers>1</font> )
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( -<font CLASS=numbers>1</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> BufferedRead ;


<font CLASS=comment>(*
   HandleEscape - translates \n and \t into their respective ascii codes.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> HandleEscape (<font CLASS=keyword>VAR</font> dest: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>; src: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>;
                        <font CLASS=keyword>VAR</font> i, j: <font CLASS=keyword>CARDINAL</font>; HighSrc, HighDest: <font CLASS=keyword>CARDINAL</font>) ;
<font CLASS=keyword>BEGIN</font>
   IF (i+1&lt;HighSrc) AND (src[i]=<font CLASS=strings>'\') AND (j&lt;HighDest)
   THEN
      IF src[i+1]='</font>n<font CLASS=strings>'
      THEN
         <font CLASS=comment>(* requires a newline *)</font>
         dest[j] := nl ;
         INC(j) ;
         INC(i, <font CLASS=numbers>2</font>)
      <font CLASS=keyword>ELSIF</font> src[i+<font CLASS=numbers>1</font>]=<font CLASS=strings>'t'</font>
      <font CLASS=keyword>THEN</font>
         <font CLASS=comment>(* requires a tab (yuck) tempted to fake this but I better not.. *)</font>
         dest[j] := tab ;
         INC(j) ;
         INC(i, <font CLASS=numbers>2</font>)
      <font CLASS=keyword>ELSE</font>
         <font CLASS=comment>(* copy escaped character *)</font>
         INC(i) ;
         dest[j] := src[i] ;
         INC(j) ;
         INC(i)
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> HandleEscape ;


<font CLASS=comment>(*
   StringFormat1 - converts string, src, into, dest, together with encapsulated
                   entity, w. It only formats the first %s or %d with n.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> StringFormat1 (<font CLASS=keyword>VAR</font> dest: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>; src: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>; w: WORD) ;
<font CLASS=keyword>VAR</font>
   HighSrc,
   HighDest,
   i, j    : <font CLASS=keyword>CARDINAL</font> ;
   str     : <font CLASS=keyword>ARRAY</font> [<font CLASS=numbers>0</font>..MaxErrorString] <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font> ;
   p       : <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> <font CLASS=keyword>CHAR</font> ;
<font CLASS=keyword>BEGIN</font>
   HighSrc := StrLen(src) ;
   HighDest := HIGH(dest) ;
   i := <font CLASS=numbers>0</font> ;
   j := <font CLASS=numbers>0</font> ;
   <font CLASS=keyword>WHILE</font> (i&lt;HighSrc) <font CLASS=keyword>AND</font> (src[i]#nul) <font CLASS=keyword>AND</font> (j&lt;HighDest) <font CLASS=keyword>AND</font> (src[i]#<font CLASS=strings>'%'</font>) <font CLASS=keyword>DO</font>
      IF src[i]=<font CLASS=strings>'\'
      THEN
         HandleEscape(dest, src, i, j, HighSrc, HighDest)
      ELSE
         dest[j] := src[i] ;
         INC(i) ;
         INC(j)
      END
   END ;

   IF (i+1&lt;HighSrc) AND (src[i]='</font>%<font CLASS=strings>') AND (j&lt;HighDest)
   THEN
      IF src[i+1]='</font>s<font CLASS=strings>'
      THEN
         p := w ;
         WHILE (j&lt;HighDest) AND (p^#nul) DO
            dest[j] := p^ ;
            INC(j) ;
            INC(p)
         END ;
         IF j&lt;HighDest
         THEN
            dest[j] := nul
         END ;
         j := StrLen(dest) ;
         INC(i, 2)
      ELSIF src[i+1]='</font>d<font CLASS=strings>'
      THEN
         dest[j] := nul ;
         CardToStr(w, 0, str) ;
         StrConCat(dest, str, dest) ;
         j := StrLen(dest) ;
         INC(i, 2)
      ELSE
         dest[j] := src[i] ;
         INC(i) ;
         INC(j)
      END
   END ;
   <font CLASS=comment>(* and finish off copying src into dest *)</font>
   <font CLASS=keyword>WHILE</font> (i&lt;HighSrc) <font CLASS=keyword>AND</font> (src[i]#nul) <font CLASS=keyword>AND</font> (j&lt;HighDest) <font CLASS=keyword>DO</font>
      IF src[i]=<font CLASS=strings>'\'
      THEN
         HandleEscape(dest, src, i, j, HighSrc, HighDest)
      ELSE
         dest[j] := src[i] ;
         INC(i) ;
         INC(j)
      END
   END ;
   IF j&lt;HighDest
   THEN
      dest[j] := nul
   END ;
END StringFormat1 ;


<font CLASS=comment>(*
   FormatError - provides a orthoganal counterpart to the procedure below.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> FormatError (a: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>) ;
<font CLASS=keyword>BEGIN</font>
   WriteString(StdErr, a)
<font CLASS=keyword>END</font> FormatError ;


<font CLASS=comment>(*
   FormatError1 - fairly generic error procedure.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> FormatError1 (a: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>; w: WORD) ;
<font CLASS=keyword>VAR</font>
   s: <font CLASS=keyword>ARRAY</font> [<font CLASS=numbers>0</font>..MaxErrorString] <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font> ;
<font CLASS=keyword>BEGIN</font>
   StringFormat1(s, a, w) ;
   FormatError(s)
<font CLASS=keyword>END</font> FormatError1 ;


<font CLASS=comment>(*
   FormatError2 - fairly generic error procedure.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> FormatError2 (a: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>; w1, w2: WORD) ;
<font CLASS=keyword>VAR</font>
   s: <font CLASS=keyword>ARRAY</font> [<font CLASS=numbers>0</font>..MaxErrorString] <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font> ;
<font CLASS=keyword>BEGIN</font>
   StringFormat1(s, a, w1) ;
   FormatError1(s, w2)
<font CLASS=keyword>END</font> FormatError2 ;


<font CLASS=comment>(*
   CheckAccess - checks to see whether a file, f, has been
                 opened for read/write.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> CheckAccess (f: File; use: FileUsage; towrite: <font CLASS=keyword>BOOLEAN</font>) ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>IF</font> FileInfo[f]=NIL
      <font CLASS=keyword>THEN</font>
         FormatError(<font CLASS=strings>'this file has probably been closed and not reopened successfully or alternatively never opened\n'</font>) ;
         HALT
      <font CLASS=keyword>ELSE</font>
         <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
            <font CLASS=keyword>IF</font> (use=openedforwrite) <font CLASS=keyword>AND</font> (usage=openedforread)
            <font CLASS=keyword>THEN</font>
               FormatError1(<font CLASS=strings>'this file (%s) has been opened for reading but is now being written\n'</font>,
                            WORD(name.address)) ;   <font CLASS=comment>(* cast only necessary for p2c *)</font>
               HALT
            <font CLASS=keyword>ELSIF</font> (use=openedforread) <font CLASS=keyword>AND</font> (usage=openedforwrite)
            <font CLASS=keyword>THEN</font>
               FormatError1(<font CLASS=strings>'this file (%s) has been opened for writing but is now being read\n'</font>,
                            WORD(name.address)) ;   <font CLASS=comment>(* cast only necessary for p2c *)</font>
               HALT
            <font CLASS=keyword>ELSIF</font> state=connectionfailure
            <font CLASS=keyword>THEN</font>
               FormatError1(<font CLASS=strings>'this file (%s) was not successfully opened\n'</font>,
                            WORD(name.address)) ;   <font CLASS=comment>(* cast only necessary for p2c *)</font>
               HALT
            <font CLASS=keyword>ELSIF</font> towrite#output
            <font CLASS=keyword>THEN</font>
               <font CLASS=keyword>IF</font> output
               <font CLASS=keyword>THEN</font>
                  FormatError1(<font CLASS=strings>'this file (%s) was opened for writing but is now being read\n'</font>,
                               WORD(name.address)) ;   <font CLASS=comment>(* cast only necessary for p2c *)</font>
                  HALT
               <font CLASS=keyword>ELSE</font>
                  FormatError1(<font CLASS=strings>'this file (%s) was opened for reading but is now being written\n'</font>,
                               WORD(name.address)) ;   <font CLASS=comment>(* cast only necessary for p2c *)</font>
                  HALT
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font>
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>ELSE</font>
      FormatError(<font CLASS=strings>'this file has not been opened successfully\n'</font>) ;
      HALT
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> CheckAccess ;


<font CLASS=comment>(*
   ReadChar - returns a character read from file, f.
              Sensible to check with IsNoError or EOF after calling
              this function.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> ReadChar (f: File) : <font CLASS=keyword>CHAR</font> ;
<font CLASS=keyword>VAR</font>
   ch: <font CLASS=keyword>CHAR</font> ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforread, <font CLASS=keyword>FALSE</font>) ;
   <font CLASS=keyword>IF</font> BufferedRead(f, SIZE(ch), ADR(ch))=SIZE(ch)
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>RETURN</font>( ch )
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( nul )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> ReadChar ;


<font CLASS=comment>(*
   UnReadChar - replaces a character, ch, back into file, f.
                This character must have been read by ReadChar
                and it does not allow successive calls.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> UnReadChar (f: File ; ch: <font CLASS=keyword>CHAR</font>) ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforread, <font CLASS=keyword>FALSE</font>) ;
   <font CLASS=keyword>IF</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL)
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=keyword>IF</font> buffer#NIL
         <font CLASS=keyword>THEN</font>
            <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
               <font CLASS=comment>(* we assume that a ReadChar has occurred, we will check just in case. *)</font>
               <font CLASS=keyword>IF</font> (position&gt;<font CLASS=numbers>0</font>) <font CLASS=keyword>AND</font> (filled&gt;<font CLASS=numbers>0</font>)
               <font CLASS=keyword>THEN</font>
                  DEC(position) ;
                  INC(left) ;
                  contents^[position] := ch
               <font CLASS=keyword>ELSE</font>
                  FormatError1(<font CLASS=strings>'performing too many UnReadChar call on file (%s)\n'</font>, <font CLASS=keyword>INTEGER</font>(f))
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font>
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> UnReadChar ;


<font CLASS=comment>(*
   ReadAny - reads HIGH(a) bytes into, a. All input
             is fully buffered, unlike ReadNBytes and thus is more
             suited to small reads.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> ReadAny (f: File; <font CLASS=keyword>VAR</font> a: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> BYTE) ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforread, <font CLASS=keyword>FALSE</font>) ;
   <font CLASS=keyword>IF</font> BufferedRead(f, HIGH(a), ADR(a))=HIGH(a)
   <font CLASS=keyword>THEN</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> ReadAny ;


<font CLASS=comment>(*
   EOF - tests to see whether a file, f, has reached end of file.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> EOF (f: File) : <font CLASS=keyword>BOOLEAN</font> ;
<font CLASS=keyword>VAR</font>
   ch: <font CLASS=keyword>CHAR</font> ;
   s : FileStatus ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforread, <font CLASS=keyword>FALSE</font>) ;
   <font CLASS=comment>(*
      we will read a character and then push it back onto the input stream,
      having noted the file status, we also reset the status.
   *)</font>
   <font CLASS=keyword>IF</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL) <font CLASS=keyword>AND</font> (FileInfo[f]^.state=successful)
   <font CLASS=keyword>THEN</font>
      ch := ReadChar(f) ;
      s := FileInfo[f]^.state ;
      <font CLASS=keyword>IF</font> s=successful
      <font CLASS=keyword>THEN</font>
         UnReadChar(f, ch) ;
         FileInfo[f]^.state := s ;
         <font CLASS=keyword>RETURN</font>( <font CLASS=keyword>FALSE</font> )
      <font CLASS=keyword>ELSE</font>
         <font CLASS=keyword>RETURN</font>( <font CLASS=keyword>TRUE</font> )
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( <font CLASS=keyword>TRUE</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> EOF ;


<font CLASS=comment>(*
   EOLN - tests to see whether a file, f, is upon a newline.
          It does NOT consume the newline.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> EOLN (f: File) : <font CLASS=keyword>BOOLEAN</font> ;
<font CLASS=keyword>VAR</font>
   ch: <font CLASS=keyword>CHAR</font> ;
   s : FileStatus ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforread, <font CLASS=keyword>FALSE</font>) ;
   <font CLASS=comment>(*
      we will read a character and then push it back onto the input stream,
      having noted the file status, we also reset the status.
   *)</font>
   <font CLASS=keyword>IF</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL)
   <font CLASS=keyword>THEN</font>
      ch := ReadChar(f) ;
      s := FileInfo[f]^.state ;
      UnReadChar(f, ch) ;
      FileInfo[f]^.state := s ;
      <font CLASS=keyword>RETURN</font>( (s=successful) <font CLASS=keyword>AND</font> (ch=nl) )
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( <font CLASS=keyword>FALSE</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> EOLN ;


<font CLASS=comment>(*
   WriteLine - writes out a linefeed to file, f.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> WriteLine (f: File) ;
<font CLASS=keyword>BEGIN</font>
   WriteChar(f, nl)
<font CLASS=keyword>END</font> WriteLine ;


<font CLASS=comment>(*
   WriteNBytes - writes nBytes of a file into memory area, a, returning
                 the number of bytes actually written.
                 This function will flush the buffer and then
                 write the nBytes using a direct write from libc.
                 It is ideal for large writes.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> WriteNBytes (f: File; nBytes: <font CLASS=keyword>CARDINAL</font>; a: ADDRESS) : <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>VAR</font>
   total: <font CLASS=keyword>INTEGER</font> ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforwrite, <font CLASS=keyword>TRUE</font>) ;
   FlushBuffer(f) ;
   <font CLASS=keyword>IF</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL)
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         total := write(unixfd, a, <font CLASS=keyword>INTEGER</font>(nBytes)) ;
         <font CLASS=keyword>IF</font> total&lt;<font CLASS=numbers>0</font>
         <font CLASS=keyword>THEN</font>
            state := failed ;
            <font CLASS=keyword>RETURN</font>( <font CLASS=numbers>0</font> )
         <font CLASS=keyword>ELSE</font>
            <font CLASS=keyword>RETURN</font>( <font CLASS=keyword>CARDINAL</font>(total) )
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( <font CLASS=numbers>0</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> WriteNBytes ;


<font CLASS=comment>(*
   BufferedWrite - will write, nBytes, through the buffer.
                   Similar to WriteNBytes, but this function will always
                   write into the buffer before copying into memory.

                   Useful when performing small writes.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> BufferedWrite (f: File; nBytes: <font CLASS=keyword>CARDINAL</font>; a: ADDRESS) : <font CLASS=keyword>INTEGER</font> ;
<font CLASS=keyword>VAR</font> 
   result: <font CLASS=keyword>INTEGER</font> ;
   total,
   n     : <font CLASS=keyword>INTEGER</font> ;
   p     : <font CLASS=keyword>POINTER</font> <font CLASS=keyword>TO</font> BYTE ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      total := <font CLASS=numbers>0</font> ;   <font CLASS=comment>(* how many bytes have we read *)</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=keyword>IF</font> buffer#NIL
         <font CLASS=keyword>THEN</font>
            <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
               <font CLASS=keyword>WHILE</font> nBytes&gt;<font CLASS=numbers>0</font> <font CLASS=keyword>DO</font>
                  <font CLASS=comment>(* place into the buffer first *)</font>
                  <font CLASS=keyword>IF</font> left&gt;<font CLASS=numbers>0</font>
                  <font CLASS=keyword>THEN</font>
                     <font CLASS=keyword>IF</font> nBytes=<font CLASS=numbers>1</font>
                     <font CLASS=keyword>THEN</font>
                        <font CLASS=comment>(* too expensive to call MemCopy for 1 character *)</font>
                        p := a ;
                        contents^[position] := p^ ;
                        DEC(left) ;         <font CLASS=comment>(* reduce space                        *)</font>
                        INC(position) ;     <font CLASS=comment>(* move onwards n byte                 *)</font>
                        INC(total) ;
                        INC(abspos) ;
                        <font CLASS=keyword>RETURN</font>( total )
                     <font CLASS=keyword>ELSE</font>
                        n := Min(left, nBytes) ;
                        MemCopy(a, <font CLASS=keyword>CARDINAL</font>(n), ADDRESS(<font CLASS=keyword>CARDINAL</font>(address)+position)) ;
                        DEC(left, n) ;      <font CLASS=comment>(* remove consumed bytes               *)</font>
                        INC(position, n) ;  <font CLASS=comment>(* move onwards n bytes                *)</font>
                                            <font CLASS=comment>(* move ready for further writes       *)</font>
                        a := ADDRESS(<font CLASS=keyword>CARDINAL</font>(a)+n) ;
                        DEC(nBytes, n) ;    <font CLASS=comment>(* reduce the amount for future writes *)</font>
                        INC(total, n) ;
                        INC(abspos, n)
                     <font CLASS=keyword>END</font>
                  <font CLASS=keyword>ELSE</font>
                     FlushBuffer(f) ;
                     <font CLASS=keyword>IF</font> state#successful
                     <font CLASS=keyword>THEN</font>
                        nBytes := <font CLASS=numbers>0</font>
                     <font CLASS=keyword>END</font>
                  <font CLASS=keyword>END</font>
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font> ;
            <font CLASS=keyword>RETURN</font>( total )
         <font CLASS=keyword>ELSE</font>
            <font CLASS=keyword>RETURN</font>( -<font CLASS=numbers>1</font> )
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( -<font CLASS=numbers>1</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> BufferedWrite ;


<font CLASS=comment>(*
   FlushBuffer - flush contents of file, f.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> FlushBuffer (f: File) ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> (f&lt;MaxNoOfFiles) <font CLASS=keyword>AND</font> (FileInfo[f]#NIL)
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=keyword>IF</font> output <font CLASS=keyword>AND</font> (buffer#NIL)
         <font CLASS=keyword>THEN</font>
            <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
               <font CLASS=keyword>IF</font> (position=<font CLASS=numbers>0</font>) <font CLASS=keyword>OR</font> (write(unixfd, address, position)=position)
               <font CLASS=keyword>THEN</font>
                  position := <font CLASS=numbers>0</font> ;
                  filled   := <font CLASS=numbers>0</font> ;
                  left     := size
               <font CLASS=keyword>ELSE</font>
                  state := failed
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font>
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> FlushBuffer ;


<font CLASS=comment>(*
   WriteAny - writes HIGH(a) bytes onto, file, f. All output
              is fully buffered, unlike WriteNBytes and thus is more
              suited to small writes.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> WriteAny (f: File; <font CLASS=keyword>VAR</font> a: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> BYTE) ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforwrite, <font CLASS=keyword>TRUE</font>) ;
   <font CLASS=keyword>IF</font> BufferedWrite(f, HIGH(a), ADR(a))=HIGH(a)
   <font CLASS=keyword>THEN</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> WriteAny ;


<font CLASS=comment>(*
   WriteChar - writes a single character to file, f.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> WriteChar (f: File; ch: <font CLASS=keyword>CHAR</font>) ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforwrite, <font CLASS=keyword>TRUE</font>) ;
   <font CLASS=keyword>IF</font> BufferedWrite(f, SIZE(ch), ADR(ch))=SIZE(ch)
   <font CLASS=keyword>THEN</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> WriteChar ;


<font CLASS=comment>(*
   WriteCardinal - writes a CARDINAL to file, f.
                   (here for compatibility - suggest that WriteAny be used instead)
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> WriteCardinal (f: File; c: <font CLASS=keyword>CARDINAL</font>) ;
<font CLASS=keyword>BEGIN</font>
   WriteAny(f, c)
<font CLASS=keyword>END</font> WriteCardinal ;


<font CLASS=comment>(*
   ReadCardinal - reads a CARDINAL from file, f.
                  (here for compatibility - suggest that ReadAny be used instead)
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> ReadCardinal (f: File) : <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>VAR</font>
   c: <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>BEGIN</font>
   ReadAny(f, c) ;
   <font CLASS=keyword>RETURN</font>( c )
<font CLASS=keyword>END</font> ReadCardinal ;


<font CLASS=comment>(*
   ReadString - reads a string from file, f, into string, a.
                It terminates the string if HIGH is reached or
                if a newline is seen or an error occurs.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> ReadString (f: File; <font CLASS=keyword>VAR</font> a: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>) ;
<font CLASS=keyword>VAR</font>
   high,
   i   : <font CLASS=keyword>CARDINAL</font> ;
   ch  : <font CLASS=keyword>CHAR</font> ;
<font CLASS=keyword>BEGIN</font>
   CheckAccess(f, openedforread, <font CLASS=keyword>FALSE</font>) ;
   high := HIGH(a) ;
   i := <font CLASS=numbers>0</font> ;
   <font CLASS=keyword>REPEAT</font>
      ch := ReadChar(f) ;
      <font CLASS=keyword>IF</font> i&lt;=high
      <font CLASS=keyword>THEN</font>
         <font CLASS=keyword>IF</font> (ch=nl) <font CLASS=keyword>OR</font> (<font CLASS=keyword>NOT</font> IsNoError(f))
         <font CLASS=keyword>THEN</font>
            a[i] := nul ;
            INC(i)
         <font CLASS=keyword>ELSE</font>
            a[i] := ch ;
            INC(i)
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>UNTIL</font> (ch=nl) <font CLASS=keyword>OR</font> (i&gt;high) <font CLASS=keyword>OR</font> (<font CLASS=keyword>NOT</font> IsNoError(f))
<font CLASS=keyword>END</font> ReadString ;


<font CLASS=comment>(*
   SetPositionFromBeginning - sets the position from the beginning of the file.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> SetPositionFromBeginning (f: File; pos: <font CLASS=keyword>CARDINAL</font>) ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=comment>(* always force the lseek, until we are confident that abspos is always correct,
            basically it needs some hard testing before we should <font CLASS=comment>remove the OR TRUE. *)</font></font>
         <font CLASS=keyword>IF</font> (abspos#pos) <font CLASS=keyword>OR</font> <font CLASS=keyword>TRUE</font>
         <font CLASS=keyword>THEN</font>
            FlushBuffer(f) ;
            <font CLASS=keyword>IF</font> buffer#NIL
            <font CLASS=keyword>THEN</font>
               <font CLASS=keyword>WITH</font> buffer^ <font CLASS=keyword>DO</font>
                  <font CLASS=keyword>IF</font> output
                  <font CLASS=keyword>THEN</font>
                     left := size
                  <font CLASS=keyword>ELSE</font>
                     left := <font CLASS=numbers>0</font>
                  <font CLASS=keyword>END</font> ;
                  position := <font CLASS=numbers>0</font> ;
                  filled   := <font CLASS=numbers>0</font>
               <font CLASS=keyword>END</font>
            <font CLASS=keyword>END</font> ;
            abspos := pos ;
            <font CLASS=keyword>IF</font> lseek(unixfd, <font CLASS=keyword>INTEGER</font>(pos), SEEK_SET)#INTEGER(pos)
            <font CLASS=keyword>THEN</font>
               state  := failed ;
               abspos := <font CLASS=numbers>0</font>
            <font CLASS=keyword>END</font>
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> SetPositionFromBeginning ;


<font CLASS=comment>(*
   FindPosition - returns the current absolute position in file, f.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> FindPosition (f: File) : <font CLASS=keyword>CARDINAL</font> ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
   <font CLASS=keyword>THEN</font>
      <font CLASS=keyword>WITH</font> FileInfo[f]^ <font CLASS=keyword>DO</font>
         <font CLASS=keyword>RETURN</font>( abspos )
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>RETURN</font>( <font CLASS=numbers>0</font> )
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> FindPosition ;


<font CLASS=comment>(*
   PreInitialize - preinitialize the file descriptor.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> PreInitialize (f: File; fname: <font CLASS=keyword>ARRAY</font> <font CLASS=keyword>OF</font> <font CLASS=keyword>CHAR</font>;
                         state: FileStatus; use: FileUsage; towrite: <font CLASS=keyword>BOOLEAN</font>; bufsize: <font CLASS=keyword>CARDINAL</font>) ;
<font CLASS=keyword>BEGIN</font>
   NEW(FileInfo[f]) ;
   <font CLASS=keyword>IF</font> FileInfo[f]=NIL
   <font CLASS=keyword>THEN</font>
      HALT   <font CLASS=comment>(* out of memory already, serious problems *)</font>
   <font CLASS=keyword>ELSE</font>
      <font CLASS=keyword>IF</font> InitializeFile(f, fname, state, use, towrite, bufsize)=f
      <font CLASS=keyword>THEN</font>
         <font CLASS=keyword>IF</font> f&lt;MaxNoOfFiles
         <font CLASS=keyword>THEN</font>
            FileInfo[f]^.unixfd := <font CLASS=keyword>INTEGER</font>(f)
         <font CLASS=keyword>ELSE</font>
            FileInfo[f]^.unixfd := FileInfo[StdErr]^.unixfd    <font CLASS=comment>(* the error channel *)</font>
         <font CLASS=keyword>END</font>
      <font CLASS=keyword>ELSE</font>
         HALT
      <font CLASS=keyword>END</font>
   <font CLASS=keyword>END</font>
<font CLASS=keyword>END</font> PreInitialize ;


<font CLASS=comment>(*
   Init - initialize the modules, global variables.
<font CLASS=comment>*)</font></font>

<font CLASS=keyword>PROCEDURE</font> Init ;
<font CLASS=keyword>VAR</font>
   f: File ;
<font CLASS=keyword>BEGIN</font>
   <font CLASS=keyword>FOR</font> f := <font CLASS=numbers>0</font> <font CLASS=keyword>TO</font> MaxNoOfFiles <font CLASS=keyword>DO</font>
      FileInfo[f] := NIL
   <font CLASS=keyword>END</font> ;
   StdIn := <font CLASS=numbers>0</font> ;
   PreInitialize(StdIn       , <font CLASS=strings>'stdin'</font> , successful      , openedforread , <font CLASS=keyword>FALSE</font>, MaxBufferLength) ;
   StdOut := <font CLASS=numbers>1</font> ;
   PreInitialize(StdOut      , <font CLASS=strings>'stdout'</font>, successful      , openedforwrite,  <font CLASS=keyword>TRUE</font>, MaxBufferLength) ;
   StdErr := <font CLASS=numbers>2</font> ;
   PreInitialize(StdErr      , <font CLASS=strings>'stderr'</font>, successful      , openedforwrite,  <font CLASS=keyword>TRUE</font>, MaxBufferLength) ;
   <font CLASS=comment>(* and now for the error file descriptor *)</font>
   PreInitialize(MaxNoOfFiles, <font CLASS=strings>'error'</font> , toomanyfilesopen, unused        , <font CLASS=keyword>FALSE</font>, <font CLASS=numbers>0</font>) ;
<font CLASS=keyword>END</font> Init ;


<font CLASS=keyword>BEGIN</font>
   Init
<font CLASS=keyword>END</font> FIO.



</pre>



</body>
</html>
